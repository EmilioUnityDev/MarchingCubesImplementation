#pragma kernel SmoothTopNoise
 
RWStructuredBuffer<float4> points;
// Read Only float2 buffer for points noise
StructuredBuffer<float2> pointsNoise;

int numPointsPerAxis;
float chunkSize;
bool isTopLayer;

float4 mod(float4 x, float4 y)
{
    return x - y * floor(x / y);
}

float4 mod289(float4 x)
{
    return x - floor(x / 289.0) * 289.0;
}

float4 permute(float4 x)
{
    return mod289(((x * 34.0) + 1.0) * x);
}

float4 taylorInvSqrt(float4 r)
{
    return (float4) 1.79284291400159 - r * 0.85373472095314;
}

float2 fade(float2 t)
{
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

// Classic Perlin noise
float cnoise(float2 P)
{
    float4 Pi = floor(P.xyxy) + float4(0.0, 0.0, 1.0, 1.0);
    float4 Pf = frac(P.xyxy) - float4(0.0, 0.0, 1.0, 1.0);
    Pi = mod289(Pi); // To avoid truncation effects in permutation
    float4 ix = Pi.xzxz;
    float4 iy = Pi.yyww;
    float4 fx = Pf.xzxz;
    float4 fy = Pf.yyww;

    float4 i = permute(permute(ix) + iy);

    float4 gx = frac(i / 41.0) * 2.0 - 1.0;
    float4 gy = abs(gx) - 0.5;
    float4 tx = floor(gx + 0.5);
    gx = gx - tx;

    float2 g00 = float2(gx.x, gy.x);
    float2 g10 = float2(gx.y, gy.y);
    float2 g01 = float2(gx.z, gy.z);
    float2 g11 = float2(gx.w, gy.w);

    float4 norm = taylorInvSqrt(float4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x;
    g01 *= norm.y;
    g10 *= norm.z;
    g11 *= norm.w;

    float n00 = dot(g00, float2(fx.x, fy.x));
    float n10 = dot(g10, float2(fx.y, fy.y));
    float n01 = dot(g01, float2(fx.z, fy.z));
    float n11 = dot(g11, float2(fx.w, fy.w));

    float2 fade_xy = fade(Pf.xy);
    float2 n_x = lerp(float2(n00, n01), float2(n10, n11), fade_xy.x);
    float n_xy = lerp(n_x.x, n_x.y, fade_xy.y);
    return 2.3 * n_xy;
}

[numthreads(8,8,8)]
void SmoothTopNoise(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numPointsPerAxis || id.y >= numPointsPerAxis || id.z >= numPointsPerAxis)
        return;
        
    int index = id.x + id.y * numPointsPerAxis + id.z * numPointsPerAxis * numPointsPerAxis;
    
    float3 posInChunk = float3( // Position of the point in the chunk [0,1] scalated to the chunk size [0, chunkSize]
        ((float) id.x / (numPointsPerAxis - 1)) * chunkSize,
        ((float) id.y / (numPointsPerAxis - 1)) * chunkSize,
        ((float) id.z / (numPointsPerAxis - 1)) * chunkSize
    );
    
    if (!isTopLayer)
    {
        // If not on the top layer, set the point to one
        points[index] = float4(
            posInChunk,
            1.0f // Set the iso value to 1
        );
        return;
    }
    else
    {
        float noiseValue = pointsNoise[id.x + id.z * numPointsPerAxis].x;
        if ((float) id.y / (numPointsPerAxis - 1) < noiseValue)
        {
            // If the y position is less than the noise value, set the iso value to 1
            points[index] = float4(
                posInChunk,
                1.0f // Set the iso value to 1
            );
        }
        else
        {
            // Otherwise, set the iso value to 0
            points[index] = float4(
                posInChunk,
                noiseValue // Set the iso value to the noise value
            );
        }
    }
}
